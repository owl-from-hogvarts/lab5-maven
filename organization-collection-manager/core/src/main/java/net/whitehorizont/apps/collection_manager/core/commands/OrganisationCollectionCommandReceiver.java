package net.whitehorizont.apps.collection_manager.core.commands;


import java.util.List;
import java.util.NoSuchElementException;

import org.eclipse.jdt.annotation.NonNullByDefault;
import org.javatuples.Pair;

import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;
import net.whitehorizont.apps.collection_manager.core.collection.errors.DuplicateElements;
import net.whitehorizont.apps.collection_manager.core.collection.errors.NoSuchElement;
import net.whitehorizont.apps.collection_manager.core.collection.interfaces.ICollection;
import net.whitehorizont.apps.collection_manager.core.collection.keys.BaseId;
import net.whitehorizont.apps.collection_manager.core.collection.keys.ElementKey;
import net.whitehorizont.apps.collection_manager.core.collection.keys.UUID_ElementId;
import net.whitehorizont.apps.collection_manager.core.storage.errors.StorageInaccessibleError;
import net.whitehorizont.apps.collection_manager.organisation.commands.IOrganisationCollectionCommandReceiver;
import net.whitehorizont.apps.collection_manager.organisation.definitions.OrganisationElementDefinition;
import net.whitehorizont.apps.collection_manager.organisation.definitions.OrganisationType;
import net.whitehorizont.apps.collection_manager.organisation.definitions.OrganisationElementDefinition.OrganisationElementAutogenerated;
import net.whitehorizont.apps.collection_manager.organisation.definitions.OrganisationElementDefinition.OrganisationElementFull;
import net.whitehorizont.apps.collection_manager.organisation.definitions.OrganisationElementDefinition.OrganisationElementWritable;
import net.whitehorizont.apps.organization_collection_manager.lib.FieldMetadataExtended.Tag;
import net.whitehorizont.apps.organization_collection_manager.lib.validators.ValidationError;

/**
 * Specialized collection receiver for Organisation type of collection
 */
@NonNullByDefault
public class OrganisationCollectionCommandReceiver extends CollectionCommandReceiver<OrganisationElementFull> implements IOrganisationCollectionCommandReceiver {

  public OrganisationCollectionCommandReceiver(ICollection<OrganisationElementFull> collection) {
    super(collection);
  }

  @Override
  public Observable<Void> replaceById(String owner, BaseId id, OrganisationElementWritable prototype) {
    final var entries = this.getOwnedWithKey$(owner)
        .filter(keyElement -> OrganisationElementDefinition.ID_METADATA.getValueGetter().apply(keyElement.getValue1())
            .equals(id));
    final var amount = entries.count().blockingGet();
    if (amount < 1) {
      return Observable.error(new NoSuchElement(id, owner));
    }

    // iteration would happen over freshly constructed list so
    // no concurrent modification exception should happen
    return entries.toList().flatMapObservable(list -> Observable.fromIterable(list)).flatMap(keyElement -> {
      final var base = keyElement.getValue1();
      try {
        final var updatedPrototype = new OrganisationElementWritable();
        // fill updatedPrototype with values from base
        OrganisationElementDefinition.getInputMetadata().fill(updatedPrototype, base.getElement());
        // update all fields except with PRESERVE tag
        OrganisationElementDefinition.getInputMetadata().fill(updatedPrototype, prototype, Tag.PRESERVE);
        final var element = new OrganisationElementFull(base.getMetadata(), updatedPrototype);
        // do replace
        final var key = keyElement.getValue0();
        this.replace(key, element);
        return Observable.empty();
      } catch (ValidationError | NoSuchElement e) {
        return Observable.error(e);
      }
    });
  }

  @Override
  public Single<Long> countByType(OrganisationType type) {
    return this.getEvery$()
        .filter(element -> OrganisationElementDefinition.TYPE_METADATA.getValueGetter().apply(element.getElement()) == type).count();
  }

  @Override
  public Single<ElementKey> removeById(String owner, UUID_ElementId id) {
    return this.getOwnedWithKey$(owner)
        .filter(keyElement -> OrganisationElementDefinition.ID_METADATA.getValueGetter()
            .apply(keyElement.getValue1())
            .equals(id))
        .singleOrError()
        .map(keyElement -> keyElement.getValue0())
        .doOnSuccess(key -> this.delete(key))
        .onErrorResumeNext(error -> {
          if (error instanceof IllegalArgumentException || error instanceof NoSuchElementException) {
            return Single.error(new NoSuchElement(id, owner));
          }

          return Single.error(error);
        });
  }

  @Override
  public void removeByRevenue(String owner, RemovalCriteria removalCriteria, double targetValue) throws ValidationError, StorageInaccessibleError {
    final var keysToDelete = this.getOwnedWithKey$(owner).filter(keyElement -> {
      final @NonNull var currentAnnualTurnover = OrganisationElementDefinition.ANNUAL_TURNOVER_METADATA.getValueGetter()
          .apply(keyElement.getValue1().getElement());
      return switch (removalCriteria) {
        case ABOVE -> currentAnnualTurnover > targetValue;
        case BELOW -> currentAnnualTurnover < targetValue;
        default -> {
          throw new RuntimeException();
        }
      };
    })
        .map(keyElement -> keyElement.getValue0()).toList().blockingGet();

    for (final var key : keysToDelete) {
      try {
        this.delete(key);
      } catch (NoSuchElement _ignore) {
        // should never happen
        assert false;
        throw new RuntimeException();
      }
    }
  }

  @Override
  public Observable<Pair<ElementKey, OrganisationElementFull>> getStartsWith$(String startOfFullName) {
    return this.getEveryWithKey$().filter(keyElement -> OrganisationElementDefinition.FULL_NAME_METADATA
        .getValueGetter().apply(keyElement.getValue1().getElement()).startsWith(startOfFullName));
  }

  @Override
  public Observable<Pair<ElementKey, OrganisationElementFull>> getDescending$() {
    return this.getEveryWithKey$().sorted((a, b) -> {
      final var aElement = a.getValue1();
      final var bElement = b.getValue1();
      // b to a to reverse order
      return bElement.compareTo(aElement);
    });
  }

  @Override
  public void insert(String key, OrganisationElementWritable element) throws ValidationError, DuplicateElements, StorageInaccessibleError {
    final var entireElement = createElement(element);
    this.insert(key, entireElement);
  }

  private OrganisationElementFull createElement(OrganisationElementWritable element) {
    return new OrganisationElementFull(new OrganisationElementAutogenerated(), element);
  }

  @Override
  public Observable<List<OrganisationElementFull>> getAll$() {
    return super.getAll$();
  }

  @Override
  public Observable<OrganisationElementFull> getEvery$() {
    return super.getEvery$().sorted(this::compareByName);
  }

  @Override
  public Observable<Pair<ElementKey, OrganisationElementFull>> getEveryWithKey$() {
    return super.getEveryWithKey$().sorted((a, b) -> {
      return compareByName(a.getValue1(), b.getValue1());
    });
  }

  private int compareByName(OrganisationElementFull a, OrganisationElementFull b) {
      final var getter = OrganisationElementDefinition.NAME_METADATA.getValueGetter();
      final String aName = getter.apply(a.getElement());
      final String bName = getter.apply(b.getElement());

      return aName.compareTo(bName);
  }

  @Override
  public void insert(String owner, String key, OrganisationElementWritable element)
      throws ValidationError, DuplicateElements, StorageInaccessibleError {
        final var entireElement = createElement(element);
        entireElement.getMetadata().setOwner(owner);

        this.insert(key, entireElement);
      }

  private Observable<Pair<ElementKey, OrganisationElementFull>> getOwnedWithKey$(String owner) {
    return super.getEveryWithKey$().filter(keyElement -> OrganisationElementDefinition.OWNER_METADATA.getValueGetter().apply(keyElement.getValue1()).equals(owner));
  }

  @Override
  public void clear(String owner) {
    this.getOwnedWithKey$(owner).doOnNext(keyElement -> this.delete(keyElement.getValue0())).blockingSubscribe();
  }
}
